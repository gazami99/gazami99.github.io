[ { "title": "Scikit-learn", "url": "/posts/Scikit-learn/", "categories": "Python, scikit-learn", "tags": "python", "date": "2022-06-27 10:42:00 +0900", "snippet": "" }, { "title": "알고리즘 연습 [타겟넘버]", "url": "/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%97%B0%EC%8A%B5-%ED%83%80%EA%B2%9F-%EB%84%98%EB%B2%84/", "categories": "Algorithm, practice", "tags": "practice", "date": "2022-06-26 11:18:00 +0900", "snippet": "[프로그래머스 문제 연습 : 타겟넘버]flowchart LR; A[타겟 값 추정] --&gt; C; C(초과 숫자 제외 ) --&gt; E; E[타겟값 보다 낮을시 \\nQueue 추가] --&gt; G; G --&gt; |마지막 숫자 까지 \\n반복|C; G[(모든 queue 값 \\n조합)] --&gt; I; I[조합가능 수 \\n return]; 숫자 배열에서 임의로 선택해 목표 값을 만드는 문제이다. 모든 경우의수를 만들어 모두 대조해볼수 있지만 방법을 조금더 좁혀보자.모든 숫자들 더해서 숫자를 임의로 선택해 빼준다면 선택할수 있는 숫자를 제한할수 있다.타겟넘버 = 총합 - (선택한숫자합)*2 선택하면 총합에서 제외 되므로 2를 곱해준다.그럼 우리가 찾아야할건 선택한 숫자합이므로선택한 숫자합 = (총합 -타겟넘버)/2 이다.가능한 숫자조합을 좁혔으니 숫자조합 알고리즘을 만들면,숫자를 골라 선택한숫자합보다 같거나 크다면 제외 단,같을시 제외 하면서 가능한 숫자로 1+작다면 큐에 넣고 큐에 가능한 숫자와 대조한후 모든 숫자를 반복하면 모든 가능한 경우의 조합 수가 나온다.만약 숫자배열을 정렬하면 경우의수를 더줄일수 있을거 같다.import collections as coldef solution(numbers, target): answer = 0 num_sum = sum(numbers) num_case = 0 num_deque = col.deque() ### deque BFS minus_target = int((num_sum - target)/2) for k in range(len(numbers)): i = numbers.pop() if i &gt;= minus_target: num_case += int(i==minus_target) continue loop = num_deque.copy() for j in loop: tmp = num_deque.popleft() tmp_sum = tmp +i num_deque.append(tmp) if tmp_sum &lt; minus_target: num_deque.append(tmp_sum) elif tmp_sum == minus_target: num_case += 1 num_deque.append(i) answer = num_case return answer" }, { "title": "알고리즘 연습 [다리를 지나는 트럭]", "url": "/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%97%B0%EC%8A%B5-%EB%8B%A4%EB%A6%AC%EB%A5%BC-%EC%A7%80%EB%82%98%EB%8A%94-%ED%8A%B8%EB%9F%AD/", "categories": "Algorithm, practice", "tags": "practice", "date": "2022-06-14 01:19:00 +0900", "snippet": "[프로그래머스 문제 연습 : 다리를 지나는 트럭] graph RL; A(트럭 출발 ) --&gt; B[하중제한 다리]; B --&gt; C(도착);큐를 생성에 다리길이만큼 크기에 큐에 들어갈때마다 시간을 측정하고 무게를 더하고 하중보다 초과하면큐에 트럭무게대신 0을 넣고 큐에 자료가 빠질때마다 총무게에 빠져나간 무게를 빼주면 해결된다.그런데, 이문제를 잘 관찰하면 출발할때 우리는 이미 트럭이 언제 도착할지 예측할수 있다!도착시간 = 현재시간 + 다리길이 +1 이다.만약 하중제한이 걸리지않는다면 트럭대기열 + 다리길이 일것이다.그래서 큐에 넣을때마다 시간을 1씩 추가하고 시간과 무게를 함께 넣어줄것이다.그리고 다음에 넣어줄때마다 큐가 빠져나갈 시간과 무게를 체크한다이게 가능한이유는 이미 도착시간이 정해져있기 때문에,관심사는 미뤄졋을때에 빠져나가는 시간을 현재시간으로 생각하면 되기때문이다또한 과거시간은 고려대상이아니기에 그것도 빼준다.시간복잡도는 O(2n) flowchart LR; A[트럭] --&gt; C; C(Queue 값 도착시간,무게 데이터 조회\\n 무게초과 or 과거시간) --&gt; E; E[조건 만족시 \\nQueue 데이터 처리 \\n 시간은 마지막 데이터처리 기준] --&gt; G; C --&gt; |무게 이하 and 미래시간|G; G --&gt; |마지막 트럭까지 반복|C; G[(Queue 추가\\n도착시간 \\n 트럭무게)] --&gt; I; I[마지막 트럭 \\n시간 return];def solution(bridge_length, weight, truck_weights): answer = 0 queue = [] sum_w = 0 # 다리에 걸리는 하중 br_len = bridge_length #다리길이 time = br_len #도착시간 answer = time for t_w in (truck_weights): time = time + 1 sum_w = sum_w + t_w while queue and (sum_w&gt; weight or (time-br_len) &gt;= queue[0][0]): ## 하중제한이 걸리거나 현재시간 보다 과거시간일때 큐 빼주기 tmp = queue.pop(0) # list.pop(0) 시간복잡도 O(n) 하지만 queue라 생각하기 sum_w = sum_w - tmp[1] time = tmp[0] + br_len # ## queue 데이터 처리가 끝나면 트럭이 출발하기 때문에 그시간은 마지막 데이터 시간 queue.append([time,t_w]) # 큐에 넣는 데이터 도착시간,무게 answer = time return answer" }, { "title": "pymysql", "url": "/posts/pymysql/", "categories": "Python, pymysql", "tags": "python", "date": "2022-06-14 01:19:00 +0900", "snippet": "pymysql 파이썬에서 MySQL, MariaDB DBMS와 연동하는 다양한 함수를 제공하는 모듈 Python DB API 2.0 표준을 따른다. https://github.com/PyMySQL/PyMySQL/ https://pymysql.readthedocs.io/en/latest/설치 조건 python version 3.6 이상 mysql version 5.6 이상 설치 pip install PyMySQL conda install -y -c conda-forge pymysql 기본 작성 절차 Database 연결 connection = pymysql.connect(host=\"DBMS 서버 ip\", port=\"port번호\", user=\"계정명\", password=\"비밀번호\", db=\"연결할데이터베이스이름\", charset='utf8') port 번호 기본값: 3306 Connection을 이용해 Cursor 생성 Cursor: 연결된 Database에 sql문을 전송하고 select결과 조회 기능을 제공하는 객체 cursor = connection.cursor() Cusror를 이용해 SQL문 전송 cursor.execute(\"sql문\") 연결 닫기 cursor, connection 연결을 닫는다. with문을 이용할 수 있다. cursor.close() connection.close() import pymysql# DB 연결 - connect() =&gt; 연결 실패시 Exception 발생connection = pymysql.connect(host='127.0.0.1', # localhost 적어도가능 port=3306, user='scott', password='tiger', db='testdb')DMLinsertimport pymysql # auto commit=Falsesql = \"insert into test_user (name, email, tall, birthday) values ('홍길동', 'hong@a.com', 182.23, '2000-02-03')\"try: # 연결 connection = pymysql.connect(host='127.0.0.1', port=3306, user='scott', password='tiger', db='testdb', charset='utf8') # cursor 생성 cursor = connection.cursor() # insert문 실행 cnt = cursor.execute(sql) connection.commit() # insert/delete/update 문 실행 후 commit 처리를 해야 한다. print(f\"{cnt} 행이 insert 되었습니다.\") except Exception as e: if connection: connection.rollback() print(e)finally:# 연결 닫기 if cursor: # if cursor!=None: cursor.close() if connection: # != None: connection.close()# with 문# with 연결함수 as 변수sql = \"insert into test_user (name, email, tall, birthday) values ('홍길동2', 'hong2@a.com', 172.23, '2005-02-03')\"with pymysql.connect(host='127.0.0.1', port=3306, user='scott', password='tiger', db='testdb', charset='utf8') as connection: with connection.cursor() as cursor: cnt = cursor.execute(sql) print(f'{cnt} 행이 insert됨') connection.commit()" } ]
